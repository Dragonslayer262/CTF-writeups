# GreyCTF 2022
Grey Cat The Flag 2022 was organized by NUS Greyhats in collaboration with National Cybersecurity R&D Labs from Singapore
## Overview 


### Cube (51 solves) 
#### Challenge: 
I have a super computer so I can run this!

```
from Crypto.Util.number import bytes_to_long, getPrime, isPrime

FLAG = <REDACTED>

def gen(n):
    while True:
        p = getPrime(n - 1) * 2 + 1
        if (isPrime(p)):
            return p

def cube(m, n, p):
    res = m
    for i in range(n):
        res = (res * res * res) % p
    return res

p = gen(1024)
m = bytes_to_long(FLAG)
c = cube(m, 2 ** 100, p)

print(p)
print(c)

# p = 147271787827929374875021125075644322658199797362157810465584602627709052665153637157027284239972360505065250939071494710661089022260751215312981674288246413821920620065721158367282080824823494257083257784305248518512283466952090977840589689160607681176791401729705268519662036067738830529129470059752131312559
# c = 117161008971867369525278118431420359590253064575766275058434686951139287312472337733007748860692306037011621762414693540474268832444018133392145498303438944989809563579460392165032736630619930502524106312155019251740588974743475569686312108671045987239439227420716606411244839847197214002961245189316124796380
```

#### Solution: 
The challenge is asking us to find $m$ where $m^{3^{2^{100}}} \equiv c \space ( mod \space p)$ 
#### Fermat Little Theorem 
Fermat little theorem states that 

$ a^{p-1} \equiv 1 \space (mod \space p) $ 

By Fermat Little theorem, we know that

$m^{3^{2^{100}}} \equiv k \space (mod \space p-1) $

This results in RSA encryption where $N=p$ and $\phi(N) = p-1$
decryption key d can be subsequently found using mod inverse 
### Solution Script
```
from Crypto.Util.number import *
p = 147271787827929374875021125075644322658199797362157810465584602627709052665153637157027284239972360505065250939071494710661089022260751215312981674288246413821920620065721158367282080824823494257083257784305248518512283466952090977840589689160607681176791401729705268519662036067738830529129470059752131312559
c = 117161008971867369525278118431420359590253064575766275058434686951139287312472337733007748860692306037011621762414693540474268832444018133392145498303438944989809563579460392165032736630619930502524106312155019251740588974743475569686312108671045987239439227420716606411244839847197214002961245189316124796380
# a^p-1 = 1 (mod p )
power = pow(2,100)
k = pow(3,power,p-1)
d = inverse(k,p-1)
print(long_to_bytes(pow(c,d,p)))
```


